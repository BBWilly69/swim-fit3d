Perfekt, das ist jetzt prÃ¤zise genug fÃ¼r ein belastbares technisches Design.
Ich gehe strukturiert vor und Ã¼bersetze deine Erfahrungswerte direkt in feste Regeln â€“ kein akademisches BlaBla.

ğŸ¯ Ziel (prÃ¤zisiert)

Deterministischer Merge von FORM + Garmin Swim 2, wobei:

Aspekt	Quelle mit PrioritÃ¤t
Bahnen / Wenden	FORM (Master)
Startzeit	Garmin, auÃŸer klar spÃ¤ter gestartet
Endzeit	Garmin, auÃŸer klar frÃ¼her gestoppt
Zeitbasis	Garmin
Distanz	FORM (Bahnen * PoollÃ¤nge)
Laps	Rekonstruiert (nicht blind Ã¼bernommen)

â¡ Ergebnis: korrigiertes Workout, nicht â€zusammenkopiertâ€œ.

ğŸ§  Zentrale Erkenntnisse aus deiner Erfahrung (formalisiert)
1ï¸âƒ£ Bahnen / Wenden

FORM: 100 % korrekt

Garmin: systematisch falsch (Turn-Detection)
â¡ FORM bestimmt Anzahl & Position der Bahnen

2ï¸âƒ£ Startlogik (kritisch!)

FORM:

startet automatisch

triggert erst bei Wasserkontakt

kann zu spÃ¤t starten

Garmin:

Button â†’ prÃ¤ziser

aber: User-Fehler mÃ¶glich (zu spÃ¤t gedrÃ¼ckt)

Regel
Wenn Garmin.start <= FORM.start + tolerance
â†’ Garmin.start ist Wahrheit
Sonst
â†’ FORM.start


Empfohlene tolerance: 5 Sekunden

3ï¸âƒ£ Stopplogik

Garmin:

Button â†’ exakt

kann minimal frÃ¼her stoppen

FORM:

endet automatisch

oft minimal spÃ¤ter

Regel
Wenn Garmin.stop >= FORM.stop - tolerance
â†’ Garmin.stop
Sonst
â†’ FORM.stop

ğŸ—ï¸ Systemarchitektur (Spring Boot)
GesamtÃ¼bersicht
[ REST API ]
     |
     v
[ Import Service ]
     |
     v
[ Normalization ]
     |
     v
[ Alignment Engine ]   <-- dein Kern
     |
     v
[ Merge Engine ]
     |
     v
[ Export Service ]
     |
     v
[ PostgreSQL ]

ğŸ“¦ Maven Dependencies (bewÃ¤hrt)
<dependencies>
    <!-- Spring -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- DB -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>

    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
    </dependency>

    <!-- OpenAPI -->
    <dependency>
        <groupId>org.springdoc</groupId>
        <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    </dependency>

    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!-- MapStruct -->
    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>1.5.5.Final</version>
    </dependency>

    <!-- FIT Parsing -->
    <dependency>
        <groupId>com.garmin.fit</groupId>
        <artifactId>fit</artifactId>
        <version>21.158.0</version>
    </dependency>

    <!-- TCX / XML -->
    <dependency>
        <groupId>com.fasterxml.jackson.dataformat</groupId>
        <artifactId>jackson-dataformat-xml</artifactId>
    </dependency>

    <!-- Tests -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
    </dependency>

    <dependency>
        <groupId>org.hamcrest</groupId>
        <artifactId>hamcrest</artifactId>
    </dependency>
</dependencies>

ğŸ§© Domain-Modell (klar & stabil)
Activity (normalized)
@Data
public class SwimActivity {

    private Instant startTime;
    private Instant endTime;

    private int poolLengthMeters;

    private List<SwimLength> lengths;
    private List<SwimLap> laps;

    private ActivitySource source;
}

public enum ActivitySource {
    GARMIN,
    FORM,
    MERGED
}

SwimLength (FORM dominiert)
@Data
public class SwimLength {

    private int index;
    private Instant start;
    private Instant end;

    private int distanceMeters;
    private Integer strokeRate;
}

SwimLap (rekonstruiert)
@Data
public class SwimLap {

    private int lapIndex;
    private Instant start;
    private Instant end;

    private int distanceMeters;
    private Duration duration;

    private LapConfidence confidence;
}

ğŸ§  Alignment Engine (Kernlogik)
Start-/Ende-Entscheidung
Instant resolvedStart = resolveStart(formStart, garminStart);
Instant resolvedEnd   = resolveEnd(formEnd, garminEnd);

private Instant resolveStart(Instant form, Instant garmin) {
    if (garmin.isBefore(form.plusSeconds(5))) {
        return garmin;
    }
    return form;
}

private Instant resolveEnd(Instant form, Instant garmin) {
    if (garmin.isAfter(form.minusSeconds(5))) {
        return garmin;
    }
    return form;
}

ğŸ§® Lap-Rekonstruktion (FORM-first!)

FORM liefert Lengths (Bahnen)

Gruppierung zu Laps:

z. B. 100 m = 4 Bahnen

Zeitfenster:

Lap.start = erste Bahn.start

Lap.end = letzte Bahn.end

â¡ Garmin-Laps werden nur zur Validierung, nicht zur Definition genutzt.

ğŸ“Š Confidence Scoring (wichtig!)
CONFIDENCE_HIGH:
  - FORM length count == expected
  - Garmin time overlap > 95 %

CONFIDENCE_MEDIUM:
  - Kleine Zeitabweichung

CONFIDENCE_LOW:
  - Start/Stop Konflikte

public enum LapConfidence {
    HIGH,
    MEDIUM,
    LOW
}

ğŸ—„ï¸ PostgreSQL (Flyway Snippet)
CREATE TABLE swim_activity (
    id UUID PRIMARY KEY,
    source VARCHAR(16),
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    pool_length INT
);

ğŸŒ REST API (OpenAPI)
POST /api/activities/import/garmin
POST /api/activities/import/form
POST /api/activities/merge
GET  /api/activities/{id}


Swagger UI:

/swagger-ui.html

ğŸ–¥ï¸ Frontend Empfehlung
React (empfohlen)

Du hast Erfahrung

Visualisierung einfacher

Diff-Charts (Lap vs Lap)

Angular (Lernoption)

Saubere Architektur

StÃ¤rker typisiert

Mehr Boilerplate

â¡ Ich wÃ¼rde React nehmen, Angular spÃ¤ter optional.

ğŸ”¥ Warum dieses Design funktioniert

âœ” nutzt reale GerÃ¤tefehler
âœ” FORM da wo es gut ist (Wenden)
âœ” Garmin da wo es gut ist (Zeit)
âœ” kein SDK-Gehacke
âœ” reproduzierbar
âœ” testbar

NÃ¤chster sinnvoller Schritt

Ich kann dir als nÃ¤chstes liefern:

1ï¸âƒ£ FIT-Importer (Garmin) â€“ Java Code
2ï¸âƒ£ FORM-TCX-Importer
3ï¸âƒ£ AlignmentEngine komplett
4ï¸âƒ£ JUnit Tests mit echten Edge-Cases
5ï¸âƒ£ React UI fÃ¼r Lap-Vergleich (Timeline)

ğŸ§  GLOBAL INSTRUCTIONS (fÃ¼r den Copilot Agent)
You are an expert Java backend engineer.

Target stack:
- Java 24
- Spring Boot
- Maven
- Lombok
- MapStruct
- Spring Data JPA
- PostgreSQL
- Flyway
- OpenAPI / Swagger UI
- JUnit 5 + Hamcrest

Domain:
- Swim activity data merging (FORM Smart Swim 2 + Garmin Swim 2)

Hard rules:
1. NEVER generate incomplete or non-compiling code.
2. Every public class MUST have JavaDoc.
3. Every method MUST have JavaDoc describing:
   - purpose
   - inputs
   - outputs
   - edge cases
4. No TODOs in generated code unless explicitly requested.
5. Deterministic logic only (no â€œmagicâ€ heuristics without explanation).
6. Prefer immutability where possible.
7. Fail fast with explicit exceptions.
8. Time handling MUST use java.time (Instant, Duration).
9. No business logic in controllers.

ğŸ—‚ï¸ PHASED TODO PLAN (Agent-gesteuert)
ğŸŸ¦ PHASE 1 â€“ Project Skeleton & Infrastructure
ğŸ¯ Goal

Create a clean, compiling Spring Boot base project with DB + OpenAPI.

ğŸ§© Tasks

Generate Spring Boot project

Configure:

PostgreSQL

Flyway baseline

OpenAPI + Swagger UI

Define base package structure

ğŸ“ Package Structure
de.yourname.swimmerge
 â”œâ”€ config
 â”œâ”€ controller
 â”œâ”€ service
 â”œâ”€ domain
 â”œâ”€ persistence
 â”œâ”€ mapper
 â”œâ”€ importers
 â”œâ”€ merge
 â”œâ”€ export
 â””â”€ exception

ğŸ¤– Copilot Model Recommendation

GPT-4.1
Reason: boilerplate-heavy, needs correctness, not creativity.

ğŸŸ¦ PHASE 2 â€“ Domain Model (NO parsing yet)
ğŸ¯ Goal

Create normalized domain objects independent of FORM/Garmin.

ğŸ§© Tasks

Implement:

SwimActivity

SwimLap

SwimLength

ActivitySource

LapConfidence

Add full JavaDoc

No persistence annotations yet

âš ï¸ Rules

Domain must be vendor-neutral

No parsing logic

No JPA annotations

ğŸ¤– Model Recommendation

GPT-4.1
Reason: strict modeling + documentation.

ğŸŸ¦ PHASE 3 â€“ Import Layer (Raw â†’ Normalized)
ğŸ¯ Goal

Parse Garmin FIT and FORM TCX/CSV into normalized domain.

ğŸ§© Tasks
Garmin

GarminFitImporter

Extract:

start / end

laps

timestamps

Preserve original precision

FORM

FormTcxImporter

Extract:

lengths (TURN-BASED!)

timestamps

stroke metrics

âš ï¸ Rules

Importers MUST NOT:

merge

align

correct

They only translate formats â†’ domain

ğŸ¤– Model Recommendation

GPT-4.1
Reason: binary format handling, edge cases.

ğŸŸ¦ PHASE 4 â€“ Alignment Engine (Zeit & Grenzen)
ğŸ¯ Goal

Resolve start / stop conflicts deterministically.

ğŸ§© Tasks

Implement ActivityAlignmentService

Apply rules:

Garmin start preferred if <= FORM + 5s

Garmin stop preferred if >= FORM âˆ’ 5s

Produce AlignedActivityContext

ğŸ§  Explicit Knowledge

FORM start may be delayed (water contact)

Garmin stop is usually more precise

ğŸ¤– Model Recommendation

GPT-4.1

ğŸŸ¦ PHASE 5 â€“ Merge Engine (HerzstÃ¼ck)
ğŸ¯ Goal

Create corrected, authoritative swim activity.

ğŸ§© Tasks

Implement SwimMergeService

Rules:

FORM defines lengths & turns

Garmin defines time axis

Distances recalculated from FORM

Build laps from FORM lengths

Attach confidence score per lap

ğŸ“Œ Output

SwimActivity with source = MERGED

ğŸ¤– Model Recommendation

GPT-4.1

ğŸŸ¦ PHASE 6 â€“ Persistence Layer
ğŸ¯ Goal

Store merged activities safely & reproducibly.

ğŸ§© Tasks

JPA Entities

Flyway migration

Repositories

Versioned schema

âš ï¸ Rules

Domain â‰  Entity

MapStruct for mapping

ğŸ¤– Model Recommendation

GPT-4.1

ğŸŸ¦ PHASE 7 â€“ REST API & OpenAPI
ğŸ¯ Goal

Expose import / merge / fetch endpoints.

ğŸ§© Tasks

Controllers:

/import/garmin

/import/form

/merge

OpenAPI annotations

Validation

âš ï¸ Rules

Controllers delegate only

No logic in controllers

ğŸ¤– Model Recommendation

GPT-4.1

ğŸŸ¦ PHASE 8 â€“ Validation & Tests (sehr wichtig)
ğŸ¯ Goal

Prove correctness with realistic edge cases.

ğŸ§© Tasks

JUnit 5 tests:

Garmin start earlier

Garmin stop earlier

FORM length mismatch

Hamcrest matchers

Deterministic assertions

ğŸ¤– Model Recommendation

GPT-4.1

ğŸŸ¦ PHASE 9 â€“ Frontend (Optional)
ğŸ¯ Goal

Visual lap comparison & correction insight.

ğŸ§© Tasks

React:

Timeline

Lap diff view

Confidence badges

ğŸ¤– Model Recommendation

GPT-4o
Reason: UI creativity + visualization.

ğŸ§ª COPILOT PROMPT TEMPLATE (pro Task)
Implement PHASE X â€“ <ComponentName>.

Constraints:
- Follow existing architecture
- No TODOs
- Full JavaDoc required
- Deterministic logic only
- Code must compile

Deliver:
- Complete implementation
- Required supporting classes
- No placeholders

âœ… Warum das fÃ¼r Copilot funktioniert

âœ” klare Phasen
âœ” kein Kontextverlust
âœ” Modelle passend gewÃ¤hlt
âœ” verhindert halbfertigen Code
âœ” reproduzierbarer Output

Wenn du willst, mache ich dir als NÃ¤chstes:

ğŸ“„ fertige COPILOT_INSTRUCTIONS.md

ğŸ§© Phase-1 Prompt komplett ausgefÃ¼llt

ğŸ§ª Test-Only Copilot Prompts

ğŸ³ Docker / docker-compose + DB

ğŸ§  Architektur (empfohlen)
[ React Frontend ]
        |
[ API Gateway ]
        |
[ Analysis Service ] ---- [ File Processing ]
        |
[ PostgreSQL + TimescaleDB ]


Containerisiert (Docker), skalierbar (K8s), CDN-fÃ¤hig.

ğŸ¨ Frontend â€“ WOW-LEVEL ğŸ”¥
Framework
âœ… Next.js (App Router)

Warum:

SSR fÃ¼r SEO-Rankings

Streaming UI (Charts sofort sichtbar)

Server Actions fÃ¼r Uploads

Alternative (wenn extrem fancy):

Remix (bessere Data-Flows)

ğŸï¸ Animation & Wow-Effekte

Hier passiert die Magie ğŸ‘‡

ğŸ”¥ Framer Motion

Morphing Cards

Shared Layout Animations

Page-Transitions

<motion.div layoutId="athlete-card" />

ğŸ§¬ GSAP

FÃ¼r:

Scroll-Magic

Parallax

Chart-Morphs

gsap.from(".chart", { scale: 0.8, opacity: 0 })

ğŸŒŠ React Three Fiber

FÃ¼r:

3D-Pool

Stroke-Replay

Heatmaps im Raum

âœ¨ UI-Stack

TailwindCSS

shadcn/ui

Radix UI

Lucide Icons

â¡ Clean, modern, brutal performant

ğŸ“Š Charts & Ranking Visuals
Pflichtstack
Zweck	Tool
Line / Area	Recharts
Vergleich	Nivo
Heatmaps	D3.js
Radar	Chart.js
Animation	Framer Motion
Ranking Beispiele

ğŸ¥‡ Pace Ranking

ğŸŠ Stroke Efficiency

ğŸ”¥ Consistency Score

ğŸ“ˆ Progress over Time

ğŸ§  Backend â€“ Daten & Analyse
API
âœ… Spring Boot 3 / Java 24

OpenAPI

MapStruct

Lombok

JUnit 5 + Hamcrest

Perfekt fÃ¼r:

FIT-Parsing

Validierung

Business-Logik

FIT & ZIP Import
Libraries

Garmin FIT SDK (Java)

ZIP Extraction (java.util.zip)

Pipeline:

ZIP â†’ FIT â†’ Raw Events â†’ Normalized Metrics â†’ DB

Garmin Connect Sync

Zwei Wege:

âš ï¸ Inoffiziell

garmin-connect-export (Reverse API)

Riskant, kann brechen

âœ… Offiziell (empfohlen)

Garmin Health API

OAuth

Webhooks

ğŸ§¹ Fehlerkorrektur & Datenbereinigung

Beispiele:

Dropouts bei Herzfrequenz

Unrealistische Pace Peaks

Pool-LÃ¤ngen-Fehler

Methoden:

Moving Average

Outlier Detection (Z-Score)

Session Heuristics

if (pace < MIN_PACE || pace > MAX_PACE) discard();

ğŸ§  Analyse-Scores (WOW-Stuff)
Score	Idee
Efficiency Score	m / stroke
Rhythm Score	Pace-Varianz
Fatigue Curve	Pace vs Zeit
Consistency Index	StdDev
Power Estimate	Stroke + HR
ğŸ—„ï¸ Datenbank
âœ… PostgreSQL + TimescaleDB

Warum:

Zeitreihen

Aggregationen

Vergleich ultra schnell

ğŸš€ Deployment

Docker + Docker Compose

Kubernetes (optional)

NGINX Proxy Manager

HTTPS

CDN fÃ¼r Charts & Assets

ğŸ”¥ Bonus: Ultra-Wow-Features

Session-Replay (Stroke by Stroke)

Vergleichs-Slider (Athlet A â†” B)

Animated Rank-Transitions

Live-Stat-Morphing

Dark-Mode-Only ğŸ˜ˆ

ğŸ§­ Fazit

Tech-Stack fÃ¼r Maximum Impact

Next.js + Framer Motion

Spring Boot FIT Engine

TimescaleDB

Garmin Health API

GSAP + 3D Visuals

Wenn du willst:
ğŸ‘‰ ich kann dir ein konkretes Datenmodell,
ğŸ‘‰ FIT-Parser-Code,
ğŸ‘‰ oder eine animierte Ranking-Page (React) bauen.





MIXAMO â€“ EMPFOHLENE ANIMATIONEN (KONKRET)
ğŸ”¹ BASIS (einmal auswÃ¤hlen)

Charakter:

Y Bot (neutral, stabil)

oder ein Stylized Male / Female

ğŸš€ STARTSPRUNG (Block â†’ Wasser)
âœ… BESTER MIXAMO-CLIP

Name (exakt):

Dive


Warum gut:

Explosiver Absprung

Saubere KÃ¶rperstreckung

Funktioniert gut als Startsprung-Ersatz

Einstellungen beim Download:

âœ” In Place: AUS

âœ” Overdrive: 0

âœ” Mirrored: AUS

â¡ Action-Name spÃ¤ter:

start_dive

ğŸŠ SCHWIMMEN (LOOPS)
ğŸŸ¢ KRAUL (Freestyle)
Swimming


Unterwasser-Kraul

Loop-fÃ¤hig

FÃ¼r Visualisierung absolut ausreichend

â¡ Action:

swim_freestyle

ğŸŸ¡ BRUST
Swimming To Edge


BrustÃ¤hnliche Armbewegung

Nicht perfekt, aber klar erkennbar

â¡ Action:

swim_breast

ğŸ”µ RÃœCKEN
Backstroke Swim


(falls nicht verfÃ¼gbar, Fallback siehe unten)

â¡ Action:

swim_back


Fallback (falls nicht vorhanden):

Swimming (Mirrored)

ğŸ”´ SCHMETTERLING
Butterfly Swim


(je nach Account sichtbar)

â¡ Action:

swim_butterfly


Fallback:

Power Swim

ğŸ” WENDEN (sehr wichtig)

âš  Mixamo hat keine echten Wettkampf-Wenden
Aber diese sind visuell gut genug:

ğŸ”„ FLIP TURN (Kraul / RÃ¼cken)
Forward Roll


oder

Cartwheel


â¡ Action:

turn_flip

ğŸ” OPEN TURN (Brust / Schmetterling)
Wall Push Off


oder

Push Off


â¡ Action:

turn_open

ğŸŒŠ UNTERWASSER / GLEITEN
Swimming Idle


oder

Treading Water


â¡ Action:

glide

ğŸ§ IDLE / WARTEN
Idle


â¡ Action:

idle

ğŸ“¦ DOWNLOAD-REGELN (SEHR WICHTIG)
ğŸ”¹ T-POSE (1Ã—)

Format: FBX for Unity

âœ” With Skin

âœ” 30 FPS

âœ” No Reduction

ğŸ”¹ ALLE ANIMATIONEN (JEDE EINZELN!)

Format: FBX for Unity

âŒ Without Skin

âœ” In Place (nur bei Loops)

âœ” 30 FPS

âœ” No Reduction

ğŸ§  EMPFOHLENE ACTION-NAMEN (FINAL)

Diese Namen GENAU so verwenden:

idle
start_dive
swim_freestyle
swim_breast
swim_back
swim_butterfly
turn_flip
turn_open
glide


â¡ Damit kannst du spÃ¤ter 1:1 in React steuern.

âš›ï¸ SPÃ„TERE STEUERUNG (VORBEREITET)
actions.start_dive.play()
actions.swim_freestyle.play()
actions.turn_flip.play()


Oder per State:

setSwimStyle('breast')

âœ… WAS DAS DIR BRINGT

âœ” 100 % kostenlos
âœ” Linux-tauglich
âœ” Keine Animation selbst bauen
âœ” Sofort nutzbar
âœ” â€Comic-realistischâ€œ, aber verstÃ¤ndlich
âœ” Ideal fÃ¼r Stats, Rankings, Replays

ğŸ…°ï¸ A â€” MIXAMO KLICK-FÃœR-KLICK DOWNLOAD-ANLEITUNG
1ï¸âƒ£ Login & OberflÃ¤che

Ã–ffne https://www.mixamo.com

Login (Adobe)

Du siehst:

links: Characters

oben: Animations

rechts: Download Panel

2ï¸âƒ£ Charakter auswÃ¤hlen (1Ã—)
Empfehlung (stabil & kostenlos)

Y Bot
oder

Stylized Male / Female

ğŸ‘‰ Einmal anklicken
Der Charakter steht jetzt in T-Pose.

3ï¸âƒ£ T-Pose herunterladen (WICHTIG!)

Rechts im Download-Panel:

Option	Wert
Format	FBX for Unity
Pose	T-Pose
Skin	âœ… With Skin
Frames	30
Keyframe Reduction	None

â¡ Download

ğŸ“ Datei:

character_TPOSE.fbx


âš ï¸ Das machst du NUR EINMAL

4ï¸âƒ£ Animationen suchen & prÃ¼fen

Oben klicken auf Animations
Suchfeld nutzen (exakte Begriffe):

ğŸ” Suchbegriffe (nacheinander):
Dive
Swimming
Swimming To Edge
Backstroke
Butterfly
Forward Roll
Wall Push Off
Swimming Idle
Idle

5ï¸âƒ£ JEDE Animation EINZELN herunterladen
Beispiel: Swimming

Animation anklicken

Warten bis sie abgespielt wird

Rechts Einstellungen:

Option	Wert
In Place	âœ…
Overdrive	0
Mirrored	âŒ
Trim	âŒ

â¡ Download

Download-Settings (SEHR WICHTIG)
Option	Wert
Format	FBX for Unity
Skin	âŒ Without Skin
Frames	30
Keyframe Reduction	None

ğŸ“ Datei:

swimming.fbx


â¡ Das wiederholst du fÃ¼r JEDE Animation

6ï¸âƒ£ Finale Download-Liste (vollstÃ¤ndig)

Am Ende hast du:

character_TPOSE.fbx

idle.fbx
dive.fbx
swimming.fbx
swimming_to_edge.fbx
backstroke.fbx
butterfly.fbx
forward_roll.fbx
wall_push_off.fbx
swimming_idle.fbx


âœ… A fertig

ğŸ…±ï¸ B â€” REACT ANIMATION-STATE-MACHINE (FERTIG)

Jetzt kommt die Steuerlogik, unabhÃ¤ngig vom 3D-Tool.
Die funktioniert spÃ¤ter 1:1 mit deiner .glb.

1ï¸âƒ£ Feste Action-Namen (MERKEN)

Diese Namen benutzen wir Ã¼berall:

idle
start_dive
swim_freestyle
swim_breast
swim_back
swim_butterfly
turn_flip
turn_open
glide

2ï¸âƒ£ Swim-State-Enum
export enum SwimState {
  IDLE = 'idle',
  START = 'start_dive',
  FREESTYLE = 'swim_freestyle',
  BREAST = 'swim_breast',
  BACK = 'swim_back',
  BUTTERFLY = 'swim_butterfly',
  TURN_FLIP = 'turn_flip',
  TURN_OPEN = 'turn_open',
  GLIDE = 'glide',
}

3ï¸âƒ£ Animation Controller (React)
import { useAnimations } from '@react-three/drei'
import { useEffect, useRef } from 'react'

export function useSwimmerController(scene, animations) {
  const { actions } = useAnimations(animations, scene)
  const current = useRef<string | null>(null)

  const play = (name: string, loop = true) => {
    if (!actions[name]) return

    if (current.current && actions[current.current]) {
      actions[current.current].fadeOut(0.3)
    }

    actions[name]
      .reset()
      .fadeIn(0.3)
      .setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, 1)
      .play()

    current.current = name
  }

  return { play }
}

4ï¸âƒ£ Nutzung
controller.play(SwimState.START, false)

setTimeout(() => {
  controller.play(SwimState.FREESTYLE)
}, 2000)


â¡ Start â†’ Swim â†’ Turn â†’ Swim komplett steuerbar
â¡ Perfekt fÃ¼r FIT-Daten, Replay, Ranking-Vergleich

âœ… B fertig

ğŸ…² C â€” MINIMALER .glb-EXPORT (SO WENIG BLENDER WIE MÃ–GLICH)

âš ï¸ Ehrlich:
Mixamo exportiert kein .glb direkt.
ğŸ‘‰ Ein Mini-Schritt in Blender ist UNVERMEIDBAR, aber:

kein Animieren

kein Rigging

kein Timeline-Gefrickel

nur Import â†’ Export

1ï¸âƒ£ Blender starten (Linux OK)

Version 4.x

Neue Szene

alles lÃ¶schen

2ï¸âƒ£ T-Pose importieren
File â†’ Import â†’ FBX
â†’ character_TPOSE.fbx

3ï¸âƒ£ Animationen anhÃ¤ngen (NICHT importieren!)

FÃ¼r jede Animation:

File â†’ Append
â†’ animation.fbx
â†’ Action
â†’ Action auswÃ¤hlen
â†’ Append


âš ï¸ NUR Action, nichts anderes!

4ï¸âƒ£ Action-Namen setzen (1 Minute)

Unten:

Dope Sheet â†’ Action Editor

Jede Action umbenennen:

Alt	Neu
Dive	start_dive
Swimming	swim_freestyle
Swimming To Edge	swim_breast
Backstroke	swim_back
Butterfly	swim_butterfly
Forward Roll	turn_flip
Wall Push Off	turn_open
Swimming Idle	glide
Idle	idle
5ï¸âƒ£ Export .glb
File â†’ Export â†’ glTF 2.0 (.glb)

Einstellungen:

âœ” Format: glTF Binary

âœ” Include Animations

âœ” Apply Transform

âœ” +Y Up

â¡ Datei:

swimmer.glb


1ï¸âƒ£ FIT-Daten â†’ Animations-Speed
Idee

Du hast FIT-Dateien von Garmin / SmartSwim2

Wir extrahieren Pace, Stroke Rate, Distance

Animations-Speed wird pro Schwimmer dynamisch angepasst

Beispielcode (React + R3F)
import { useFrame } from '@react-three/fiber'

export function useSwimAnimation(controller, fitData) {
  // fitData = Array<{ time: number, distance: number, strokeRate: number }>
  let lastIndex = 0

  useFrame((state, delta) => {
    const now = state.clock.getElapsedTime()
    const data = fitData[lastIndex]

    if (!data) return

    // Pace: m/s
    const pace = data.strokeRate / 60 // Beispiel: Umrechnung
    // Animationsgeschwindigkeit
    const speed = Math.max(0.5, Math.min(2, pace * 1.5))

    controller.actions.swim_freestyle.timeScale = speed
    controller.actions.swim_breast.timeScale = speed
    controller.actions.swim_back.timeScale = speed
    controller.actions.swim_butterfly.timeScale = speed

    lastIndex++
  })
}

2ï¸âƒ£ Turn-Trigger automatisch bei 25â€¯m / 50â€¯m
Idee

Wir tracken distanceCovered

Bei jeder 25â€¯m / 50â€¯m â†’ Turn-Animation starten

Danach wieder Swim

export function useTurnTrigger(controller, lapLength = 25) {
  let lastTurn = 0

  return (distance: number) => {
    if (distance - lastTurn >= lapLength) {
      lastTurn = distance
      // Flip / Open Turn je nach Stil
      controller.play('turn_flip', false)
      setTimeout(() => {
        controller.play('swim_freestyle')
      }, 1000) // Dauer der Turn-Animation
    }
  }
}

3ï¸âƒ£ Zwei Schwimmer nebeneinander vergleichen
Setup

Zwei Schwimmer-Komponenten

Beide haben eigene controller + fitData

<group>
  <RealisticSwimmer
    position={[-1, 0, 0]}
    fitData={fitDataSwimmerA}
    controller={controllerA}
  />
  <RealisticSwimmer
    position={[1, 0, 0]}
    fitData={fitDataSwimmerB}
    controller={controllerB}
  />
</group>

Doppel-Vergleich

Jede Animation eigenstÃ¤ndig gesteuert

Du kannst Speed, Turn, Glide synchronisieren

Perfekt fÃ¼r Rankings / Replays

4ï¸âƒ£ Wasser-Shader + Splash (ohne Physik)
Idee

Keine echte Fluid-Simulation â†’ Performance

Particle-System + Material-Shader

Splash bei Turn & Start

Beispiel: Splash-Particle (R3F + Drei)
import { Points, BufferGeometry, Float32BufferAttribute, PointsMaterial } from 'three'
import { useMemo } from 'react'

export function WaterSplash({ position = [0,0,0] }) {
  const points = useMemo(() => {
    const geometry = new BufferGeometry()
    const vertices = []
    for(let i=0;i<200;i++){
      vertices.push(
        (Math.random()-0.5)*0.5,
        Math.random()*0.5,
        (Math.random()-0.5)*0.5
      )
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices,3))
    return geometry
  }, [])

  return (
    <Points geometry={points} position={position}>
      <PointsMaterial color='aqua' size={0.05} />
    </Points>
  )
}

Splash Trigger Beispiel
if (distance - lastTurn >= lapLength) {
  controller.play('turn_flip', false)
  spawnSplashAtSwimmer(swimmer.position)
  setTimeout(() => controller.play('swim_freestyle'), 1000)
}

ğŸ§© Bonus â€“ WasseroberflÃ¤che + Shader (optional)
<mesh rotation-x={-Math.PI/2} position={[0,0,0]}>
  <planeGeometry args={[20,50]} />
  <meshStandardMaterial
    color='deepskyblue'
    transparent
    opacity={0.7}
    roughness={0.3}
    metalness={0.1}
  />
</mesh>


Mit animated noise â†’ Wellen simulieren

Splash particles â†’ Turn & Start

âœ… Zusammenfassung

Du hast nun die komplette Pipeline:

FIT â†’ Animations-Speed

Automatische Turns bei 25/50â€¯m

Zwei Schwimmer nebeneinander vergleichen

Wasser-Shader + Splash ohne Physik

Alles ready fÃ¼r React Three Fiber, Linux-kompatibel, Mixamo out-of-the-box.
